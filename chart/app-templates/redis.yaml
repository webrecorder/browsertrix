{% if not no_pvc %}
# -------
# PVC
# -------

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{ name }}
  namespace: {{ namespace }}
  labels:
    {{ obj_type }}: {{ id }}
    role: redis

spec:
  accessModes:
    - ReadWriteOnce

  resources:
    requests:
      storage: {{ redis_storage }}

  {% if volume_storage_class %}
  storageClassName: {{ volume_storage_class }}
  {% endif %}
{% endif %}

# --------
# REDIS
# --------
{% if init_redis %}
---
apiVersion: v1
kind: Pod
metadata:
  name: {{ name }}
  namespace: {{ namespace }}
  labels:
    {{ obj_type }}: {{ id }}
    role: redis

spec:
  hostname: {{ name }}
  subdomain: redis
  securityContext:
    runAsNonRoot: true
    runAsUser: 999
    runAsGroup: 999
    fsGroup: 999

  terminationGracePeriodSeconds: 300
  restartPolicy: {{ "OnFailure" if save_dump else "Always" }}

  volumes:
    - name: shared-redis-conf
      configMap:
        name: shared-redis-conf

    - name: redis-data
      {% if not no_pvc %}
      persistentVolumeClaim:
        claimName: {{ name }}
      {% else %}
      emptyDir: {}
      {% endif %}

  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 1
          preference:
            matchExpressions:
            - key: nodeType
              operator: In
              values:
                - "{{ redis_node_type }}"

    podAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 2
          podAffinityTerm:
            topologyKey: "failure-domain.beta.kubernetes.io/zone"
            labelSelector:
              matchLabels:
                {{ obj_type }}: {{ id }}

  tolerations:
    - key: nodeType
      operator: Equal
      value: crawling
      effect: NoSchedule
    - key: node.kubernetes.io/not-ready
      operator: Exists
      tolerationSeconds: 300
      effect: NoExecute
    - key: node.kubernetes.io/unreachable
      operator: Exists
      effect: NoExecute
      tolerationSeconds: 300

  containers:
    - name: redis
      image: {{ redis_image }}
      imagePullPolicy: {{ redis_image_pull_policy }}

      {% if use_kvrocks %}
      args: ["-c", "/redis-conf/kvrocks.conf", "--dir", "/data"]
      {% else %}
      args: ["/redis-conf/redis.conf", "--appendonly", "{{ 'no' if load_dump else 'yes' }}"]
      {% endif %}

      volumeMounts:
        - name: redis-data
          mountPath: /data

        - name: shared-redis-conf
          mountPath: /redis-conf

      resources:
        limits:
          memory: {{ memory }}

        requests:
          cpu: {{ cpu }}
          memory: {{ memory }}

      readinessProbe:
        initialDelaySeconds: 10
        timeoutSeconds: 5
        exec:
          command:
            - bash
            - -c
            - "res=$(redis-cli ping); [[ $res = 'PONG' ]]"

      livenessProbe:
        initialDelaySeconds: 10
        timeoutSeconds: 5
        exec:
          command:
            - bash
            - -c
            - "res=$(redis-cli ping); [[ $res = 'PONG' ]]"

{% if save_dump %}
    - name: save
      image: rclone/rclone:latest
      command: ["sh", "-c"]
      args:
        - |
          # wait for SIGUSR1
          trap ':' SIGUSR1

          echo "Waiting for signal (SIGUSR1) when pod is done..."

          sleep 1000000 &
          sleep_pid=$!

          wait $sleep_pid

          # ignore any future signals
          trap "" SIGUSR1

          set -e

        {% if use_kvrocks %}
          if [ ! -d /data/{{ local_file_src }} ]; then
            echo "directory /data/{{ local_file_src }} doesn't exist, erroring"
            exit 1
          fi

          cd /data/{{ local_file_src }}

          set -o pipefail

          until tar cvfz - . | tee >(sha256sum > /tmp/hash.txt) | tee >(wc -c > /tmp/size.txt) | rclone --config '' rcat remote:{{ remote_file_path }}.tmp --s3-chunk-size 100M; do
            echo "retrying upload..."
            sleep 1;
          done

          # move to final location after upload, just in case
          rclone moveto --config '' remote:{{ remote_file_path }}.tmp remote:{{ remote_file_path }}

        {% else %}
          if [ ! -f /data/{{ local_file_src }} ]; then
            echo "/data/{{ local_file_src }} doesn't exist!"
            exit 1
          fi

          until rclone -vv copyto --checksum /data/{{ local_file_src }} remote:{{ remote_file_path }} --s3-chunk-size 100M; do
            echo "retrying upload..."
            sleep 1;
          done

        {% endif %}

          size=$(cat /tmp/size.txt)
          hash=$(awk '{ print $1 }' /tmp/hash.txt)

          echo ""
          echo "STATS: (size,hash): $size,$hash"

      volumeMounts: &rclone_volumes
        - name: redis-data
          mountPath: /data

      env: &rclone_env
      - name: RCLONE_CONFIG_REMOTE_TYPE
        value: "s3"

      - name: RCLONE_CONFIG_REMOTE_ACCESS_KEY_ID
        valueFrom:
          secretKeyRef:
            name: "{{ storage_secret_name }}"
            key: STORE_ACCESS_KEY

      - name: RCLONE_CONFIG_REMOTE_SECRET_ACCESS_KEY
        valueFrom:
          secretKeyRef:
            name: "{{ storage_secret_name }}"
            key: STORE_SECRET_KEY

      - name: RCLONE_CONFIG_REMOTE_REGION
        valueFrom:
          secretKeyRef:
            name: "{{ storage_secret_name }}"
            key: STORE_REGION

      - name: RCLONE_CONFIG_REMOTE_PROVIDER
        valueFrom:
          secretKeyRef:
            name: "{{ storage_secret_name }}"
            key: STORE_S3_PROVIDER

      - name: RCLONE_CONFIG_REMOTE_ENDPOINT
        value: "{{ storage_endpoint }}"

      resources: &rclone_resources
        limits:
          memory: "1000Mi"

        requests:
          memory: "200Mi"
          cpu: "50m"

{% if load_dump %}
  initContainers:
    - name: load
      image: rclone/rclone:latest

      command: ["sh", "-c"]
      args:
        - |
          set -e

          # if remote file doesn't exist, just return success (nothing to load)
          if ! rclone lsf remote:{{ remote_file_path }} > /dev/null 2>&1; then
            echo "Remote {{ remote_file_path }} does not exist, nothing to load, done"
            exit 0
          fi

        {% if use_kvrocks %}
          # only run if target dir doesn't exist yet
          if [ ! -d "/data/{{ local_file_dest }}" ]; then

            # remove existing + create new empty tmp dir
            rm -rf /data/{{ local_file_dest }}.tmp
            mkdir -p /data/{{ local_file_dest }}.tmp

            cd /data/{{ local_file_dest }}.tmp

            echo "Downloading from {{ remote_file_path }}"

            rclone --config "" cat remote:{{ remote_file_path }} | tar xzf -

            # move to final dest only if tar extract succeeds
            mv /data/{{ local_file_dest }}.tmp /data/{{ local_file_dest }}

            echo "Downloaded to /data/{{ local_file_dest }} successfully!"
          else
            echo "/data/{{ local_file_dest }} already present (likely pod restarted), not overwriting"
          fi

        {% else %}
          rclone --config "" copyto remote:{{ remote_file_path }} /data/{{ local_file_dest }}

        {% endif %}
      volumeMounts: *rclone_volumes
      env: *rclone_env
      resources: *rclone_resources
{% endif %}
{% endif %}

{% endif %}
