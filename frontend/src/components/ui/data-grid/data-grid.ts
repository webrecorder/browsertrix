import { localized, msg } from "@lit/localize";
import type { SlChangeEvent, SlInput } from "@shoelace-style/shoelace";
import clsx from "clsx";
import { css, html, nothing } from "lit";
import { customElement, property } from "lit/decorators.js";
import { ifDefined } from "lit/directives/if-defined.js";
import { nanoid } from "nanoid";
import type { EmptyObject } from "type-fest";

import { DataGridRowsController } from "./controllers/rows";
import type { DataGridRow, RowRemoveEventDetail } from "./data-grid-row";
import { renderRows } from "./renderRows";
import type { GridColumn, GridItem } from "./types";

import { TailwindElement } from "@/classes/TailwindElement";
import { pluralOf } from "@/utils/pluralize";
import { tw } from "@/utils/tailwind";

/**
 * Data grids structure data into rows and and columns.
 *
 * @slot label
 * @slot rows
 * @fires btrix-change
 * @fires btrix-remove
 */
@customElement("btrix-data-grid")
@localized()
export class DataGrid extends TailwindElement {
  static styles = css`
    :host {
      --border: 1px solid var(--sl-panel-border-color);
    }

    btrix-data-grid-row:not(:first-of-type),
    btrix-table-body ::slotted(*:nth-of-type(n + 2)) {
      border-top: var(--border) !important;
    }

    btrix-data-grid-row,
    btrix-table-body ::slotted(btrix-data-grid-row) {
      /* TODO Support different input sizes */
      min-height: calc(var(--sl-input-height-medium) + 1px);
    }
  `;

  /**
   * Set of columns.
   */
  @property({ type: Array })
  columns?: GridColumn[];

  /**
   * Set of data to be presented as rows. Omit if using the `rows` slot.
   */
  @property({ type: Array })
  items?: GridItem[];

  /**
   * Stick header row to the top of the table or the viewport.
   *
   * Horizontal scroll will be disabled if the header sticks to the viewport.
   */
  @property({ type: String })
  stickyHeader?: "table" | "viewport";

  /**
   * Item key to use as the row key, like an ID.
   * Defaults to one generated by nanoid.
   */
  @property({ type: String })
  rowKey?: string;

  /**
   * Whether rows can be removed.
   */
  @property({ type: Boolean })
  removeRows = false;

  /**
   * Whether rows can be added.
   */
  @property({ type: Boolean })
  addRows = false;

  /**
   * Make the number of rows being added configurable,
   * with a default starting value.
   */
  @property({ type: Number })
  addRowsInputValue?: number;

  /**
   * Whether cells can be edited.
   */
  @property({ type: Boolean })
  editCells = false;

  /**
   * Disable an editable grid.
   */
  @property({ type: Boolean })
  disabled?: boolean;

  /**
   * Default item for new rows.
   */
  @property({ type: Object })
  defaultItem?: EmptyObject | GridItem = {};

  /**
   * Text for form control label. Use slot to include markup.
   */
  @property({ type: String })
  formControlLabel?: string;

  /**
   * ID for form control label.
   */
  @property({ type: String })
  formControlLabelId = `label-${nanoid()}`;

  /**
   * Optional external controller for removing and adding rows,
   * if rendering rows into the `rows` slot.
   */
  @property({ attribute: false })
  rowsController = new DataGridRowsController(this);

  /**
   * Make grid focusable on validation.
   */
  @property({ type: Number, reflect: true })
  tabindex = 0;

  render() {
    if (!this.columns?.length) return;

    return html`
      <slot name="label">
        <label id=${this.formControlLabelId} class="form-label text-xs">
          ${this.formControlLabel}
        </label>
      </slot>
      <div
        class=${clsx(
          this.stickyHeader === "table" && tw`overflow-x-auto overscroll-none`,
          this.stickyHeader && tw`rounded border`,
        )}
      >
        ${this.renderTable()}
      </div>

      ${this.addRows && !this.addRowsInputValue
        ? this.renderAddButton()
        : nothing}
    `;
  }

  private renderTable() {
    if (!this.columns?.length) return;

    const cssWidths = this.columns.map((col) => col.width ?? "1fr");
    const showFooter = this.addRows && this.addRowsInputValue;

    return html`
      <btrix-table
        role="grid"
        class=${clsx(
          tw`relative size-full min-w-0`,
          // Add background color for overscroll:
          this.stickyHeader && tw`rounded bg-neutral-50`,
          // Height is required for sticky + horizontal scrolling to work:
          this.stickyHeader === "table" &&
            tw`max-h-[calc(100vh-4rem)] overflow-y-auto`,
        )}
        style="--btrix-table-grid-template-columns: ${cssWidths.join(" ")}${this
          .removeRows
          ? " max-content"
          : ""}"
        aria-labelledby=${ifDefined(
          (this.formControlLabel && this.formControlLabelId) ?? undefined,
        )}
        aria-readonly=${ifDefined(this.disabled)}
      >
        <btrix-table-head
          class=${clsx(
            tw`[--btrix-table-cell-padding:var(--sl-spacing-x-small)]`,
            this.stickyHeader
              ? tw`sticky top-0 z-10 rounded-t-[0.1875rem] border-b bg-neutral-50 [&>*:not(:first-of-type)]:border-l`
              : tw`px-px`,
          )}
        >
          ${this.columns.map(
            (col) => html`
              <btrix-table-header-cell
                class=${clsx(col.description && tw`flex-wrap`)}
              >
                ${col.label}
                ${col.description
                  ? html`
                      <sl-tooltip content=${col.description}>
                        <sl-icon
                          name="info-circle"
                          class="ml-1.5 flex-shrink-0 align-[-.175em] text-sm text-slate-500"
                        ></sl-icon>
                      </sl-tooltip>
                    `
                  : nothing}
              </btrix-table-header-cell>
            `,
          )}
          ${this.removeRows
            ? html`<btrix-table-header-cell>
                <span class="sr-only">${msg("Remove row")}</span>
              </btrix-table-header-cell>`
            : nothing}
        </btrix-table-head>
        <btrix-table-body
          class=${clsx(
            tw`[--btrix-table-cell-padding:var(--sl-spacing-x-small)]`,
            tw`bg-[var(--sl-panel-background-color)] leading-none`,
            !this.stickyHeader && [
              tw`border`,
              showFooter ? tw`rounded-t` : tw`rounded`,
            ],
          )}
          @btrix-remove=${(e: CustomEvent<RowRemoveEventDetail>) => {
            const { key } = e.detail;

            if (key) {
              this.rowsController.removeRow(key);
            } else {
              console.warn("Could not remove row without key or item");
            }
          }}
        >
          ${this.renderRows()}
        </btrix-table-body>

        ${showFooter
          ? html`
              <btrix-table-footer
                class=${clsx(
                  tw`[--btrix-table-cell-padding-x:var(--sl-spacing-2x-small)] [--btrix-table-cell-padding-y:var(--sl-spacing-x-small)]`,
                  tw`bg-[var(--sl-panel-background-color)]`,
                  this.stickyHeader
                    ? tw`border-t`
                    : tw`rounded-b border-x border-b`,
                )}
              >
                <btrix-table-row>
                  <btrix-table-cell class="col-span-full">
                    <!-- TODO Replace navigation button -->
                    <btrix-navigation-button
                      size="small"
                      @click=${() =>
                        this.rowsController.addRows(
                          this.defaultItem,
                          this.addRowsInputValue,
                        )}
                    >
                      <sl-icon name="plus-lg"></sl-icon>
                      ${msg("Add")}
                    </btrix-navigation-button>
                    <btrix-inline-input
                      value=${this.addRowsInputValue}
                      min="1"
                      max="99"
                      minlength="1"
                      maxlength="2"
                      class="ml-1 w-10"
                      @sl-change=${(e: SlChangeEvent) => {
                        const input = e.target as SlInput;
                        const value = +input.value;

                        this.addRowsInputValue = Math.max(1, value);
                        input.value = `${this.addRowsInputValue}`;
                      }}
                    ></btrix-inline-input>
                    <span class="ml-2.5 text-neutral-500">
                      ${msg("more")} ${pluralOf("rows", this.addRowsInputValue)}
                    </span>
                  </btrix-table-cell>
                </btrix-table-row>
              </btrix-table-footer>
            `
          : nothing}
      </btrix-table>
    `;
  }

  private renderRows() {
    return html`
      <slot name="rows" class="contents" @slotchange=${this.onRowSlotChange}>
        ${this.items
          ? renderRows(
              this.rowsController.rows,
              ({ id, item }) => html`
                <btrix-data-grid-row
                  key=${id}
                  .item=${item}
                  .columns=${this.columns}
                  ?removable=${this.removeRows}
                  ?editCells=${this.editCells}
                ></btrix-data-grid-row>
              `,
            )
          : nothing}
      </slot>
    `;
  }

  private readonly renderAddButton = () => {
    return html`<footer class="mt-2">
      <sl-button
        size="small"
        class="w-full"
        @click=${() => this.rowsController.addRows(this.defaultItem)}
      >
        <sl-icon slot="prefix" name="plus-lg"></sl-icon>
        <span class="text-neutral-600">${msg("Add More")}</span>
      </sl-button>
    </footer>`;
  };

  private readonly onRowSlotChange = (e: Event) => {
    const rows = (e.target as HTMLSlotElement).assignedElements();
    const assignProp = (
      el: Element,
      { name, value }: { name: keyof DataGridRow; value: string | boolean },
    ) => {
      if (el.attributes.getNamedItem(name)) return;

      if (typeof value === "boolean") {
        if (value) {
          el.setAttribute(name, "true");
        } else {
          el.removeAttribute(name);
        }
      } else {
        el.setAttribute(name, value);
      }
    };

    const removable = this.removeRows;
    const editCells = this.editCells;

    rows.forEach((el) => {
      assignProp(el, { name: "removable", value: removable });
      assignProp(el, { name: "editCells", value: editCells });

      (el as DataGridRow)["columns"] = this.columns;
    });
  };
}
