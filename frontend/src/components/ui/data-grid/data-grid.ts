import { localized, msg } from "@lit/localize";
import type { SlChangeEvent, SlInput } from "@shoelace-style/shoelace";
import clsx from "clsx";
import { html, nothing, unsafeCSS } from "lit";
import { customElement, property } from "lit/decorators.js";
import { ifDefined } from "lit/directives/if-defined.js";
import { nanoid } from "nanoid";
import type { EmptyObject } from "type-fest";

import { DataGridRowsController } from "./controllers/rows";
import type { DataGridRow, RowRemoveEventDetail } from "./data-grid-row";
import stylesheet from "./data-grid.stylesheet.css";
import type { BtrixSelectRowEvent } from "./events/btrix-select-row";
import type { GridColumn, GridItem } from "./types";

import { TailwindElement } from "@/classes/TailwindElement";
import { pluralOf } from "@/utils/pluralize";
import { tw } from "@/utils/tailwind";

const styles = unsafeCSS(stylesheet);

/**
 * Data grids structure data into rows and and columns.
 *
 * [Figma design file](https://www.figma.com/design/ySaSMMI2vctbxP3edAHXib/Webrecorder-Shoelace?node-id=1327-354&p=f)
 *
 * @slot label
 * @slot rows
 * @fires btrix-change
 * @fires btrix-remove
 * @fires btrix-select-row
 */
@customElement("btrix-data-grid")
@localized()
export class DataGrid<
  const T extends GridItem = GridItem,
> extends TailwindElement {
  static styles = styles;

  /**
   * Set of columns.
   */
  @property({ type: Array })
  columns?: GridColumn<T>[];

  /**
   * Set of data to be presented as rows. Omit if using the `rows` slot.
   */
  @property({ type: Array })
  items?: T[];

  /**
   * Stick header row to the top of the table or the viewport.
   *
   * Horizontal scroll will be disabled if the header sticks to the viewport.
   */
  @property({ type: String })
  stickyHeader?: "table" | "viewport";

  /**
   * Item key to use as the row key, like an ID.
   * Defaults to one generated by nanoid.
   */
  @property({ type: String })
  rowKey?: keyof T;

  /**
   * Whether rows can be selected, firing a `btrix-select-row` event.
   */
  @property({ type: Boolean })
  rowsSelectable = false;

  /**
   * Whether a single or multiple rows can be selected (multiple not yet implemented.)
   */
  @property({ type: String })
  selectMode: "single" | "multiple" = "single";

  /**
   * WIP: Whether rows can be expanded, revealing more content below the row.
   */
  @property({ type: Boolean })
  rowsExpandable = false;

  /**
   * Whether rows can be removed.
   */
  @property({ type: Boolean })
  rowsRemovable = false;

  /**
   * Whether rows can be added.
   */
  @property({ type: Boolean })
  rowsAddible = false;

  /**
   * Vertical alignment of content in body rows.
   */
  @property({ type: String })
  alignRows: "start" | "center" | "end" = "center";

  /**
   * Make the number of rows being added configurable,
   * with a default starting value.
   */
  @property({ type: Number })
  addRowsInputValue?: number;

  /**
   * Whether cells can be edited.
   */
  @property({ type: Boolean })
  editCells = false;

  /**
   * Disable an editable grid.
   */
  @property({ type: Boolean })
  disabled?: boolean;

  /**
   * Default item for new rows.
   */
  @property({ type: Object })
  defaultItem?: EmptyObject | GridItem = {};

  /**
   * Text for form control label. Use slot to include markup.
   */
  @property({ type: String })
  formControlLabel?: string;

  /**
   * ID for form control label.
   */
  @property({ type: String })
  formControlLabelId = `label-${nanoid()}`;

  /**
   * Optional external controller for removing and adding rows,
   * if rendering rows into the `rows` slot.
   */
  @property({ attribute: false })
  rowsController = new DataGridRowsController(this);

  render() {
    if (!this.columns?.length) return;

    return html`
      <slot name="label">
        <label id=${this.formControlLabelId} class="form-label text-xs">
          ${this.formControlLabel}
        </label>
      </slot>
      <div
        class=${clsx(
          this.stickyHeader === "table" && tw`overflow-x-auto overscroll-none`,
          this.stickyHeader && tw`rounded border`,
        )}
      >
        ${this.renderTable()}
      </div>

      ${this.rowsAddible && !this.addRowsInputValue
        ? this.renderAddButton()
        : nothing}
    `;
  }

  private renderTable() {
    if (!this.columns?.length) return;

    const cssWidths = this.columns.map((col) => col.width ?? "1fr");
    const addRowsInputValue = this.rowsAddible && this.addRowsInputValue;

    return html`
      <btrix-table
        role="grid"
        class=${clsx(
          tw`relative size-full min-w-0`,
          // Add background color for overscroll:
          this.stickyHeader && tw`rounded bg-neutral-50`,
          // Height is required for sticky + horizontal scrolling to work:
          this.stickyHeader === "table" &&
            tw`max-h-[calc(100vh-4rem)] overflow-y-auto`,
        )}
        style="--btrix-table-grid-template-columns: ${this.rowsExpandable
          ? "max-content "
          : ""}${cssWidths.join(" ")}${this.rowsRemovable
          ? " max-content"
          : ""}"
        aria-labelledby=${ifDefined(
          (this.formControlLabel && this.formControlLabelId) ?? undefined,
        )}
        aria-readonly=${ifDefined(this.disabled)}
      >
        <btrix-table-head
          class=${clsx(
            tw`[--btrix-table-cell-padding:var(--sl-spacing-x-small)]`,
            this.stickyHeader
              ? [
                  tw`sticky top-0 z-10 self-start rounded-t-[0.1875rem] border-b bg-neutral-50`,
                  !this.rowsSelectable &&
                    tw`[&>*:not(:first-of-type)]:border-l`,
                ]
              : tw`px-px`,
          )}
        >
          ${this.rowsExpandable
            ? html`
                <btrix-table-header-cell>
                  <span class="sr-only">${msg("Expand row")}</span>
                </btrix-table-header-cell>
              `
            : nothing}
          ${this.columns.map(
            (col) => html`
              <btrix-table-header-cell
                class=${clsx(
                  col.description && tw`flex-wrap`,
                  col.align === "center" && tw`justify-center`,
                  col.align === "end" && tw`justify-end`,
                )}
              >
                ${col.label}
                ${col.description
                  ? html`
                      <sl-tooltip content=${col.description}>
                        <sl-icon
                          name="info-circle"
                          class="ml-1.5 flex-shrink-0 align-[-.175em] text-sm text-slate-500"
                        ></sl-icon>
                      </sl-tooltip>
                    `
                  : nothing}
              </btrix-table-header-cell>
            `,
          )}
          ${this.rowsRemovable
            ? html`<btrix-table-header-cell>
                <span class="sr-only">${msg("Remove row")}</span>
              </btrix-table-header-cell>`
            : nothing}
        </btrix-table-head>
        <btrix-table-body
          class=${clsx(
            "data-grid-body data-grid-body--horizontalRule",
            this.stickyHeader
              ? "data-grid-body--stickyHeader"
              : "data-grid-body--not-stickyHeader",
            this.rowsSelectable && "data-grid-body--rowsSelectable",
            this.rowsAddible
              ? "data-grid-body--rowsAddible"
              : !this.addRowsInputValue && "data-grid-body--not-rowsAddible",
            this.editCells && "data-grid-body--editCells",
            tw`[--btrix-table-cell-padding:var(--sl-spacing-x-small)]`,
            tw`bg-[var(--sl-panel-background-color)] leading-none`,
            !this.stickyHeader && tw`border`,
            addRowsInputValue ? tw`rounded-t` : tw`rounded`,
          )}
          @btrix-remove=${(e: CustomEvent<RowRemoveEventDetail>) => {
            const { key } = e.detail;

            if (key) {
              this.rowsController.removeRow(key);
            } else {
              console.warn("Could not remove row without key or item");
            }
          }}
        >
          ${this.renderRows()}
        </btrix-table-body>

        ${addRowsInputValue
          ? html`
              <btrix-table-footer
                class=${clsx(
                  tw`[--btrix-table-cell-padding-x:var(--sl-spacing-2x-small)] [--btrix-table-cell-padding-y:var(--sl-spacing-x-small)]`,
                  tw`bg-[var(--sl-panel-background-color)]`,
                  this.stickyHeader
                    ? tw`border-t`
                    : tw`rounded-b border-x border-b`,
                )}
              >
                <btrix-table-row>
                  <btrix-table-cell class="col-span-full">
                    <!-- TODO Replace navigation button -->
                    <btrix-navigation-button
                      size="small"
                      @click=${() =>
                        this.rowsController.addRows(
                          this.defaultItem,
                          addRowsInputValue,
                        )}
                    >
                      <sl-icon name="plus-lg"></sl-icon>
                      ${msg("Add")}
                    </btrix-navigation-button>
                    <btrix-inline-input
                      value=${addRowsInputValue}
                      min="1"
                      max="99"
                      minlength="1"
                      maxlength="2"
                      class="ml-1 w-10"
                      @sl-change=${(e: SlChangeEvent) => {
                        const input = e.target as SlInput;
                        const value = +input.value;

                        this.addRowsInputValue = Math.max(1, value);
                        input.value = `${this.addRowsInputValue}`;
                      }}
                    ></btrix-inline-input>
                    <span class="ml-2.5 text-neutral-500">
                      ${msg("more")} ${pluralOf("rows", addRowsInputValue)}
                    </span>
                  </btrix-table-cell>
                </btrix-table-row>
              </btrix-table-footer>
            `
          : nothing}
      </btrix-table>
    `;
  }

  private renderRows() {
    return html`
      <slot name="rows" class="contents" @slotchange=${this.onRowSlotChange}>
        ${this.items
          ? this.rowsController.renderRows(
              ({ id, item }) => html`
                <btrix-data-grid-row
                  key=${id}
                  .item=${item}
                  .columns=${this.columns}
                  alignContent=${ifDefined(this.alignRows)}
                  ?removable=${this.rowsRemovable}
                  ?clickable=${this.rowsSelectable}
                  ?expandable=${this.rowsExpandable}
                  ?editCells=${this.editCells}
                  @click=${() => {
                    if (this.rowsSelectable) {
                      this.dispatchEvent(
                        new CustomEvent<BtrixSelectRowEvent["detail"]>(
                          "btrix-select-row",
                          {
                            detail: { id, item },
                            bubbles: true,
                            composed: true,
                          },
                        ),
                      );
                    }
                  }}
                ></btrix-data-grid-row>
              `,
            )
          : nothing}
      </slot>
    `;
  }

  private readonly renderAddButton = () => {
    return html`<footer class="mt-2">
      <sl-button
        size="small"
        class="w-full"
        @click=${() => this.rowsController.addRows(this.defaultItem)}
      >
        <sl-icon slot="prefix" name="plus-lg"></sl-icon>
        <span class="text-neutral-600">${msg("Add More")}</span>
      </sl-button>
    </footer>`;
  };

  private readonly onRowSlotChange = (e: Event) => {
    const rows = (e.target as HTMLSlotElement).assignedElements();
    const assignProp = (
      el: Element,
      { name, value }: { name: keyof DataGridRow; value: string | boolean },
    ) => {
      if (el.attributes.getNamedItem(name)) return;

      if (typeof value === "boolean") {
        if (value) {
          el.setAttribute(name, "true");
        } else {
          el.removeAttribute(name);
        }
      } else {
        el.setAttribute(name, value);
      }
    };

    const removable = this.rowsRemovable;
    const editCells = this.editCells;

    rows.forEach((el) => {
      assignProp(el, { name: "removable", value: removable });
      assignProp(el, { name: "editCells", value: editCells });

      (el as DataGridRow<T>)["columns"] = this.columns;
    });
  };
}
